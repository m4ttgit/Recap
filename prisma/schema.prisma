// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// User model for NextAuth.js authentication
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  password      String?
  image         String?
  emailVerified DateTime?
  role          String    @default("user") // user, admin
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  accounts      Account[]
  sessions      Session[]
  transcriptions Transcription[]
  meetingReports MeetingReport[]
  settings      Settings?
  subscriptions  Subscription[]
  usageLogs     UsageLog[]
  usageQuota    UsageQuota?
  folders       Folder[]
  tags          Tag[]
  sharedLinks   SharedLink[]
  comments      Comment[]
  activityLogs  ActivityLog[]
  integrations  Integration[]
  customVocabulary CustomVocabulary[]
  speakerProfiles SpeakerProfile[]
}

// NextAuth.js Account model
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

// NextAuth.js Session model
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// NextAuth.js VerificationToken model
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Application settings (now per-user)
model Settings {
  id                String   @id @default(cuid())
  userId            String   @unique
  asrProvider       String   @default("zai-sdk") // zai-sdk, openrouter, local
  asrModel          String?  // Model name for OpenRouter or local
  customAsrModel    String?  // Custom model name for ASR
  llmProvider       String   @default("openai") // openai, openrouter, local, anthropic
  llmModel          String   @default("gpt-4o-mini")
  customLlmModel    String?  // Custom model name for LLM
  llmApiKey         String?  @default("") // Encrypted API key
  llmBaseURL        String?  @default("") // Custom base URL
  diarizationEnabled Boolean @default(true)
  diarizationProvider String @default("pyannote") // pyannote
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Transcription (updated with user relation)
model Transcription {
  id              String   @id @default(cuid())
  userId          String?
  fileName        String
  fileSize        Int
  duration        Float?
  wordCount       Int
  transcription   String
  asrProvider     String
  asrModel        String?
  formatConverted Boolean  @default(false)
  originalFormat  String?
  createdAt       DateTime @default(now())

  user        User?           @relation(fields: [userId], references: [id], onDelete: SetNull)
  report      MeetingReport?
  folderId    String?
  folder      Folder?         @relation(fields: [folderId], references: [id], onDelete: SetNull)
  tags        TagTranscription[]
  sharedLinks SharedLink[]
  comments    Comment[]

  @@index([userId])
  @@index([createdAt])
}

// Meeting Report (updated with user relation)
model MeetingReport {
  id              String   @id @default(cuid())
  transcriptionId String   @unique
  userId          String?
  summary         String
  keyPoints       String   // JSON array
  actionItems     String   // JSON array
  participants    String   // JSON array
  date            String
  llmProvider     String
  llmModel        String
  createdAt       DateTime @default(now())

  transcription Transcription @relation(fields: [transcriptionId], references: [id], onDelete: Cascade)
  user           User?        @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([transcriptionId])
}

// Subscription for billing
model Subscription {
  id                String   @id @default(cuid())
  userId            String
  stripeCustomerId  String   @unique
  stripeSubscriptionId String @unique
  stripePriceId     String
  status            String   // active, canceled, past_due, trialing, incomplete, incomplete_expired
  currentPeriodStart DateTime
  currentPeriodEnd    DateTime
  cancelAtPeriodEnd  Boolean @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Invoice for billing
model Invoice {
  id              String   @id @default(cuid())
  userId          String
  stripeInvoiceId String   @unique
  amount          Int
  currency        String
  status          String
  dueDate         DateTime?
  paidAt          DateTime?
  createdAt       DateTime @default(now())

  @@index([userId])
}

// Pricing plans
model PricingPlan {
  id              String   @id @default(cuid())
  name            String   // Free, Pro, Team, Enterprise
  stripePriceId   String?
  monthlyPrice    Int
  yearlyPrice     Int?
  minutesPerMonth Int      // 0 for unlimited
  features        String   // JSON array of features
  isActive        Boolean  @default(true)
  sortOrder       Int
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

// Usage tracking
model UsageLog {
  id          String   @id @default(cuid())
  userId      String
  action      String   // transcribe, report_generate, etc.
  minutesUsed Float?
  tokensUsed  Int?
  cost        Float?
  metadata    String?  // JSON
  createdAt   DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([createdAt])
}

// Usage quota per user
model UsageQuota {
  id                String   @id @default(cuid())
  userId            String   @unique
  monthlyQuota      Float    // minutes
  monthlyUsed       Float    @default(0)
  currentPeriodStart DateTime
  overageProtection Boolean @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Folder for organizing transcriptions
model Folder {
  id          String   @id @default(cuid())
  userId      String
  name        String
  color       String?
  parentId    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  transcriptions Transcription[]
  parent        Folder?        @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children      Folder[]       @relation("FolderHierarchy")

  @@index([userId])
  @@index([parentId])
}

// Tag for labeling transcriptions
model Tag {
  id          String   @id @default(cuid())
  userId      String
  name        String
  color       String
  createdAt   DateTime @default(now())

  user          User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  transcriptions TagTranscription[]

  @@unique([userId, name])
  @@index([userId])
}

// Many-to-many relation between Tag and Transcription
model TagTranscription {
  tagId           String
  transcriptionId String

  tag           Tag           @relation(fields: [tagId], references: [id], onDelete: Cascade)
  transcription  Transcription @relation(fields: [transcriptionId], references: [id], onDelete: Cascade)

  @@id([tagId, transcriptionId])
  @@index([transcriptionId])
}

// Shared link for transcriptions
model SharedLink {
  id              String   @id @default(cuid())
  transcriptionId String
  userId          String
  token           String   @unique
  password        String?
  expiresAt       DateTime?
  viewCount       Int      @default(0)
  createdAt       DateTime @default(now())

  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  transcription   Transcription @relation(fields: [transcriptionId], references: [id], onDelete: Cascade)

  @@index([transcriptionId])
}

// Comment on transcriptions
model Comment {
  id              String   @id @default(cuid())
  transcriptionId String
  userId          String
  content         String
  timestamp       Float?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  transcription   Transcription @relation(fields: [transcriptionId], references: [id], onDelete: Cascade)

  @@index([transcriptionId])
}

// Activity log for audit trail
model ActivityLog {
  id          String   @id @default(cuid())
  userId      String
  action      String
  entityType  String
  entityId    String
  metadata    String?  // JSON
  createdAt   DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([entityType, entityId])
  @@index([createdAt])
}

// Third-party integrations
model Integration {
  id           String   @id @default(cuid())
  userId       String
  provider     String   // google, zoom, slack, etc.
  accessToken  String   // encrypted
  refreshToken String?  // encrypted
  settings     String?  // JSON
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@unique([userId, provider])
}

// Sync jobs for integrations
model SyncJob {
  id            String   @id @default(cuid())
  userId        String
  integrationId String
  status        String   // pending, running, completed, failed
  entityType    String
  externalId    String
  result        String?  // JSON
  error         String?
  createdAt     DateTime @default(now())
  completedAt   DateTime?

  @@index([userId, status])
}

// Custom vocabulary for better transcription
model CustomVocabulary {
  id            String   @id @default(cuid())
  userId        String
  term          String
  pronunciation String?
  category      String?
  createdAt     DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Speaker profile for identifying speakers
model SpeakerProfile {
  id        String   @id @default(cuid())
  userId    String
  speakerId String   // from ASR (SPEAKER_00, etc.)
  name      String
  email     String?
  avatar    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@unique([userId, speakerId])
}

// Analytics events
model AnalyticsEvent {
  id        String   @id @default(cuid())
  userId    String?
  eventType String   // meeting_completed, report_generated, etc.
  metadata  String?  // JSON
  createdAt DateTime @default(now())

  @@index([userId, eventType])
  @@index([createdAt])
}